1. Поскольку [] создает новый массив, таким образом, вы сравниваете один объект массива с другим объектом массива. Сравнивается не содержимое массивов, а ссылки на объекты. Они не равны, потому что это не один и тот же экземпляр объекта.
2. В заключение, использование ключевого слова const вместо var в JavaScript имеет как технические, так и человеческие преимущества. С технической точки зрения, использование const позволяет оптимизировать время компиляции и повышает эффективность выполнения. Движки JavaScript могут лучше оптимизировать код, зная, что определенные значения никогда не изменятся. С точки зрения человека, использование const добавляет коду ясности и семантического значения. Это указывает другим разработчикам на то, что определенное значение должно быть постоянным и никогда не изменится. Это может помочь предотвратить ошибки и улучшить читаемость кода. Однако важно отметить, что не вся информация, которая никогда не меняется, должна быть объявлена с помощью const. Если существует возможность изменения значения при различных обстоятельствах, вместо этого целесообразно использовать var.

3. Promise обрабатывается быстрее, чем 0-секундный setTimeout(). Из-за приоритетов цикла обработки событий задания из job queue, в которой есть обратный вызов promise, удаляются из task queue, в которой хранятся обратные вызовы setTimeout().

4. xss или отключить в настройках браузера если разработчик

5. глобальные стили в “index.html ”, файл стилей для каждого компонента, через атрибут style react компонента, свойство style к объекту стиля JavaScript
6.
- использовать хук useCallback для обработчиков событий: Хук useCallback позволяет сохранить ссылку на обработчик события и предотвратить его повторное создание при каждом рендере компонента. 
- мемоизировать с React.memo или useMemo, 
- использовать уникальные ключи (keys) при итерации через массивы или список объектов:  

7.
- Ограниченная производительность: при использовании Context API для передачи данных между компонентами возникают некоторые проблемы с производительностью. Передача данных через контекст может быть медленнее, чем передача данных через пропсы, поскольку затраты на обработку обновлений внутри компонента React Context.

- Сложность отладки: Context API может быть сложным для отладки из-за сложного потока данных. Если контекст используется неадекватно или неправильно обновляется, то может быть сложно найти и исправить проблемы.

- Несоответствие области видимости: Context API не ограничивает область видимости передаваемых данных, что может создавать конфликты, особенно в больших приложениях. Если контекст используется неправильным образом, то можно получить нежелательное изменение состояния внутренних компонентов.

- Сложность тестирования: Поскольку обновление данных в Context API осуществляется через функцию-редьюсер, то это может сделать тестирование компонента сложным. Необходимо мокать функцию-редьюсер, чтобы проверить правильность обновления состояния.

- Сложность повторного использования: Использование Context API может делать компоненты менее переиспользуемыми и связывать их с конкретным контекстом. Это может затруднить перенос компонентов в другие проекты или их повторное использование в других местах.
